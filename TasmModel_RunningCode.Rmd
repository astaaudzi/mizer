---
title: "Tasmanian model run"
author: "Asta"
date: "4 Feb 2019"
output: 
  html_document:
    code_folding: show
    toc: FALSE
    toc_float: FALSE
  pdf_document:
    toc:no
---

### Install mizer/rewiring  

```{r warning=F, message=FALSE, echo=T}

rm(list=ls())

#install.packages("mizer")
#library(devtools)
#install_github("astaaudzi/mizer", ref = "rewire-temp")
library(mizer)

```

### Data files

```{r warning=T, message=FALSE, echo=T}

#mariaParams <- read.csv(file = "C:/Users/astaa/Dropbox/asta/TasmanianModel/Parameters/Tasm_modelParamsnoHerb.csv") #16 species
mariaParams <- read.csv(file = "C:/Users/astaa/Dropbox/asta/TasmanianModel/Parameters/Tasm_Params_Optim.csv") #16 species

#inter <- read.csv(file = "C:/Users/astaa/Dropbox/asta/TasmanianModel/Parameters/Tasmanian_intNoHerb.csv") #16 species
inter <- read.csv(file = "C:/Users/astaa/Dropbox/asta/TasmanianModel/Parameters/Tasm_Inter_optim.csv") #16 species
inter <- as.matrix(inter)

#number of size groups 
no_size_groups = 200
#total_scalar = 10000 ## scalar to get initial abundance close to what is observed per survey

```

### Background spectra

```{r warning=T, message=FALSE, echo=T}

## resource params
kappa = 0.02 # 1.5 #1.5 ## 0.017g/m3 
lambda = 2.1 
w_pp_cutoff = 1 #5
r_pp = 2 
min_w_pp = 1e-10

kappa_ben = 0.035 # 0.025 and 0.017 worked, but not enough benthos in diets # 1.3 #2, most parameterisation at 1, but try higher
lambda_ben = 1.6 #1.8 used
w_bb_cutoff = 50 # 10 worked and used initially, but not enough benthos in diets # 1e2 # had 10
r_bb = 1.5 #0.4 # normally tried with 0.2, but benthos definitely gets depleted. If increased to 0.5, it leads to too many predators and crash of small fish. For rmax3 increase r_bb to 0.4, as 0.2 seems too low
min_w_bb = 0.01

kappa_alg = 0.02 # 1 #2
lambda_alg = 1.7
w_aa_cutoff = 50 
r_aa = 1 #0.2
min_w_aa = 0.01

```

### Senescence and juvenile mort functions and params 

My initial explorations show that juvenile mortality function is quite important here, because increasing exponent (juv.e) from 0.3 to 1 (very steep and quick decrease in juv mortality) made some erepros crazy high (25K). Even values of 0.7 are too high and lead to Trachinus erepro of 6. 

```{r warning=T, message=FALSE, echo=T}

## Senescence

## function to set senescence mortality and add it on top of mu_b. The function needs mizer params object to be set up first to know the number of size classes. So I run MizerParams here, but can overwrite it later as long as no_w does not change

params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, min_w_pp = min_w_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa)

#parameters for senescence mortality as used in Law et al. 2009
k.sm <- 0.8 #mortality per year at the threshold size (should be 0.5 originally)
xsw <- 0.9 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)

sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
  
  sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
  
  for (i in 1: length(sppParams$species)) {
    
    mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
    
    sen.mort.m[i,] <- mu_Sen    
  }

  # For really small species, like Trachinops predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
  sen.mort.m[which(params@species_params$w_inf < 100),] <- 0
    
  return(sen.mort.m)
  
}

## Juvenile mort 

## I also add extra juvenile mortality, because in reality background spectrum species would be imposing mortality on tiny fish, yet we don't model it here. As a result mortality curves look bell-shaped when instead they should be exponential 

juv.sm <- 5 # mortality per year at threshold
juvsw <- 2 # Size of w_min at which mortality is at juv.sm. Note that at the moment w_min is setup at 10x the egg size. 
juv.e <- 0.5 #exponent, larger values will give steeper decrease (orignal was 0.3, but it may be too slow decrease)

juv_mort = function(sppParams, params, juv.sm, juvsw, juv.e) {
  
  juv.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
  
  for (i in 1: length(sppParams$species)) {
    mu_Juv = juv.sm * 10^-(juv.e*(log(params@w) - log(juvsw*sppParams$w_min[i])))
    juv.mort.m[i,] <- mu_Juv
  }
  
  # It is most likely that for sharks or other species with large eggs (w_min of at least 1 gram), this early steep mortalit does not apply. So get rid of it
  juv.mort.m[which(params@species_params$w_min > 0.99),] <- 0
  
  return(juv.mort.m)
}

```

###Get initial abundance scalar 

```{r}
#get the minimum observed weight size group 
minobs <- min(which(params@w > 0.1))

#get mean model abundances in the observed weight groups (so they are comparable to surveys)
modelAb <- rep(NA, length(params@species_params$species))
## derive initial abundance scalar 
for (i in 1:length(mariaParams$species)) {
modelAb[i] <- (sum(params@initial_n[i,c(minobs:200)]))
}

#get a scalar between observed abundances and model abundances 
#Observed mean abundances are for survey area of 500m2 and assuming 10m depth, so 5000m3
abund_scalar <- (params@species_params$meanAb/5000)/modelAb

```

### Interaction 

```{r warning=T, message=FALSE, echo=T, eval = F}

#Reduce availability of Trachinops from 0.7 to 0.3, because predation mortality on them is huge 
availTr = 0.25  #availability of Trachinus to all other species 
availPi = 0.35
availUr = 0.25
availUrLob = 0.9 #Urchins to lobsters

# and overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availTr
inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availPi
inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob


```

###  Calibration: functions

```{r warning=FALSE, message=FALSE, echo=T}

# this function will take the upper multiplier values and set upper bounds
upper_bounds <- function(startpars, inter.opt = T, erepro.opt = T, gamma.opt = F, inter.mult = inter.mult.par, erepro.mult = erepro.mult.par, gamma.mult = gamma.mult.par, no_sp = numb_of_spp) {
  
  upper_value <- as.numeric(vector())
  
  #if we are optimising erepro, we sample them on a log scale and make sure the upper bound is below 1 (or 0.5 or whatever upper value seems reasoable)
 if (erepro.opt) {
    startpars_erepro <- startpars[c(1:no_sp)]
    upper_valueE <- startpars_erepro + log(erepro.mult) #we allow upper ereproboundary to be erepro.mult times bigger
    upper_valueE[c(which(exp(upper_valueE) > 0.15))] <- log(0.15) ## here we assume that erepro cannot be higher than 0.5
    upper_value <- c(upper_value,upper_valueE)
  }
  
 if(gamma.opt) {
    startpars_gamma <- startpars[c((no_sp+1):(no_sp*2))]
    upper_valueG <- startpars_gamma * gamma.mult
    upper_valueG[c(which(upper_valueG > (max(startpars_gamma)*2)))] <- (max(startpars_gamma)*2) # set a upper limit of gamma at twice the maximum value of the total dataset
    upper_value <- c(upper_value, upper_valueG)
 }
  
   if (inter.opt) {
   startpars_inter <- startpars[c((no_sp*2+1):(no_sp*2+4))]
   upper_valueI <- startpars_inter*inter.mult 
   upper_valueI[c(which(upper_valueI > 0.9))] <- 0.9 #here we assume that vulnerability cannot be higher than 0.9
   upper_value <- c(upper_value, upper_valueI)
  }
 
  return(upper_value)
}

lower_bounds <- function(startpars, inter.opt = T, erepro.opt = F, gamma.opt = F, inter.mult = inter.mult.par, erepro.mult = erepro.mult.par, gamma.mult = gamma.mult.par, no_sp = numb_of_spp) {
  
  lower_value <- as.numeric(vector())
  
  #if we are optimising erepro, we sample them on a log scale and make sure the upper bound is below 1 (or 0.5 or whatever upper value seems reasoable)
  if (erepro.opt) {
    startpars_erepro <- startpars[c(1:no_sp)]
    lower_valueE <- startpars_erepro - log(erepro.mult) #we allow upper ereproboundary to be erepro.mult times lower
    lower_valueE[c(which(exp(lower_valueE) < 1e-7))] <- log(1e-7) ## here we assume that erepro cannot be lower than 1e-7 (not sure this is neded...)
    lower_value <- c(lower_value, lower_valueE)
 }

    if(gamma.opt) {
    startpars_gamma <- startpars[c((no_sp+1):(no_sp*2))]
    lower_valueG <- startpars_gamma / gamma.mult
    lower_valueG[c(which(lower_valueG < (min(startpars_gamma)/2)))] <- (min(startpars_gamma)/2) # set a lower limit of gamma at half the minimum value of the total dataset 
    lower_value <- c(lower_value, lower_valueG)
    }
  
    if (inter.opt) {
    startpars_inter <- startpars[c((no_sp*2+1):(no_sp*2+4))]
    lower_valueI <- startpars_inter/inter.mult 
    lower_valueI[c(which(lower_valueI < 0.1))] <- 0.1 #here we assume that vulnerability cannot be lower than 0.1
    lower_value <- c(lower_value, lower_valueI)
  }

  
  return(lower_value)
}

#The optim function uses fn function to calculate errors
#This function will take parameter values from the optim function, will take my mizer object params to run the model (run_model function), and a few other thing

calibratePar_Tasm <- function(startpars, mariaParams, inter, meansteps= meansteps.par, effort = effort, trend.mult = trend.error.mult) {
  
# Function arguments: 
# startpars       - vectors of initial parameters for optimising (erepro, gamma  and interaction matrix values)
# mariaParams     - my species parameter file
# meansteps       - number of years to average biomass, at the end of the simulation run 

  optimizer_count <- optimizer_count + 1        #Keep runing count of function evaluations by optim()  
  assign("optimizer_count", optimizer_count, pos = .GlobalEnv)
  
  no_sp <- length(mariaParams$species)
  
### If calibrating erepro use this    
 #put optimised parameters into the param matrix
 startpars_erepro <- startpars[c(1:no_sp)]
 mariaParams$erepro <- exp(startpars_erepro) #for erepro we optimise the parameter on the log scale 
 
 #Then put the gamma values
 startpars_gamma <- startpars[c((no_sp+1):(no_sp*2))]
 mariaParams$gamma <- startpars_gamma
 
  ###now update the interaction matrix
 
 startpars_inter <- startpars[c((no_sp*2+1):(no_sp*2+4))]
  
 inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- startpars_inter[1]
inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- startpars_inter[2]
inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- startpars_inter[3]
inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- startpars_inter[4]

  #setup mizerParams object with them
   params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, min_w_pp = min_w_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa)

## update initial abundances based on observations 
#for (i in 1:length(mariaParams$species)) {
#  params@initial_n[i,] <- params@initial_n[i,] *abund_scalar[i]
#} 
 
    #and add senescence and juvenile mortality to background mortality 
    params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) + juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)

  #run the model for tmax years  
  tasm_model <- run_model(params, tmax, effort) ## run the model with the updated parameters 
  
  #compare relative biomasses 
  BiomError <- biom_error(tasm_model)
  print("Scaled biomass error")
  print(BiomError)
  
  #compare relative biomasses
  RelBioError <- relat_biom_error(tasm_model)
  print("Scaled relative biomass error")
  print(RelBioError*rel.bio.mult)  
  
  #penalise parameters that lead to long term trends 
  TrendError <- trend_error(tasm_model, tmax)
  print("Scaled trend error")
  print(TrendError*trend.mult)
  
  #Sum of all errors with relevant scalars 
  error <- BiomError + TrendError*trend.mult + RelBioError*rel.bio.mult #Sum error for biomass and trends (slopes). Since slopes are small I need to find the right multiplier to give it weight
  print("Total error")
  print(error)
  #Extinction penalty 
  #if(extinction_test){
  extinct <- Extinct_test(tasm_model)
  print("extinction error")
  print(extinct)
  
  error <- error + extinct
  #}
  
  print(paste(optimizer_count, "Error:", error))
  #print(exp(startpars)) #for erepro 
  print(startpars)
  return(error)
}

## run_model function

run_model <- function(params, tmax, effort) {
  tasm_model <- project(params, t_max = tmax, effort= effort, dt = 0.2, diet_steps = 0)
 return (tasm_model)

}

## extinction test function

Extinct_test <- function(tasm_model, extinct_threshold=extinct_threshold.par){

# This test is based on an initial biomass near what the target should be. 
# If the difference is more than 2 order of magnitude than the initial biomass, then there is a strong power penalty 
# Function arguments: 
# tasm_model          - result of project() 
# extinct_threshold   - If biomass decreases below this fraction of the initial biomass, the extintion penalty is applied 

    Biomass <- getBiomass(tasm_model) #returns tmax x species matrix
    BiomassInit<- Biomass[1,]  #biomass in the first year
    BiomassEnd<-  Biomass[dim(Biomass)[1],] #biomass in the last year 
    relB<-(BiomassEnd/BiomassInit)
    extinct.temp <- sum(1/relB[relB<extinct_threshold])
    
    return(extinct.temp)
}

## trend error function 
trend_error <- function(tasm_model, tmax) {
  Biomass <- getBiomass(tasm_model) #returns tmax x species matrix
  time <- c(burnin:tmax)  # use time from year 50 to tmax, to allow for the initial burn-in
  tr_err <- 0 #initialise trend error 
  for (i in 1:length(tasm_model@params@species_params$species)) {
     bio1 <- Biomass[c(burnin:tmax),i]
     mod <- lm(bio1 ~ time)
     slope <- as.numeric(mod$coefficients[2])
     tr_err <- tr_err + slope^2
     #print(tr_err)
  }
  
  return(tr_err)
}

## biomass error function

biom_error <- function(tasm_model, meansteps = meansteps.par){
  
  #vector of mean biomasses per survey. It ranges from 400 to 3500g 
  bio_obs <-  mariaParams$meanBio/(500*10) ## biomass per m2, so divide survey area of 500m2 and depth of 10 meters, so approximately 5000m3
  
  bio_model.t <- getBiomass(tasm_model) #years x species
  bio_model <- colMeans(bio_model.t[c((tmax - meansteps):tmax),])

  #Scale model biomasses to biomasses per survey - not sure this is needed as I scale initial abundances to biomasses per survey
  #bio_model.scaled <-bio_model * some_scalar #converts biomass from g/m3 to mtons / whole Eastern Bering Sea 

  #Get observed difference between observed and predicted biomass
  bdif<- log10(bio_obs)-log10(bio_model)
        
  b_error <-sum(na.omit(bdif^2)) # I don't think I need to scale in by variance  - Julia?
  
  #/ var(na.omit(log10(Bobs[Bobs!=0]))) #Standardize the RSS by the variance of the SSB (or biomass) observations. We're doing this because combining RSS from yeild and they on a smaller scale than biomas, but we choose to weight the data types equally (e.g., see Hilborn and Walters 1992).

  return(b_error)
}

## relative biomass error function
relat_biom_error <- function(tasm_model, meansteps = meansteps.par){
  
  #vector of mean biomasses per survey. It ranges from 400 to 3500g 
  bio_obs <-  mariaParams$meanBio/(500*10) ## biomass per m2, so divide survey area of 500m2 and depth of 10 meters, so approximately 5000m3
  rel_bio_obs <- bio_obs/(max(bio_obs))
  
  bio_model.t <- getBiomass(tasm_model) #years x species
  bio_model <- colMeans(bio_model.t[c((tmax - meansteps):tmax),])
  rel_bio_mod <- bio_model/(max(bio_model))
  
  #get the difference in relative abundances
  rel_error <- sum(abs(rel_bio_obs - rel_bio_mod))

  return(rel_error)
}

```


### Calibration: parameters

```{r warning=FALSE, message=FALSE, echo=T, eval = T}

tmax = 150 #how many years to run the model for each optimiser round. I found that 50 years is not enough, because species start going extinct after 100 years
effort = 0 #fishing mortality for calibrations
extinct_threshold.par = 0.01 #relative biomass at the end for a species to be extinct in the penalty function
burnin = 80 #how many initial years to remove for the trend error function - we only penalise trends in biomasses after initial burn-in period
trend.error.mult = 1e+10 # weight of the error function pelanlising a trend in biomass through time (we want stable biomasses). This has to be adjusted 
rel.bio.mult = 1000 # weight of the error function to compare relative biomasses. The maximum error can be 17, while the overall biomass error is ca 75 to 150. The relative biomasses are more important to get right, so this error has a weight of 100
inter.mult.par <- 2 #multiplier for the interaction paramter for upper and lower bounds - how many times do we allow the interaction to be higher/lower. The lower bound is later set at a minimum of 0.1 and the upper at a maximum of 0.8
erepro.mult.par <- 3 #multiplier for the erepro parameter for upper and lower bounds. This is on logarithmic scale. The upper bound is set at a maximum of 0.5 and lower at a a minimum of 1e-7
gamma.mult.par <- 2 #same as above but for gamma parameter. No limits for the upper bound, the lower bound is set a minimum of 1
meansteps.par <- 10 # how many final years to use for the mean species biomass to be compared with the observations
numb_of_spp <- length(mariaParams$species)

```

### Calibration: optim

```{r warning=FALSE, message=FALSE, echo=T, eval = F}
optimizer_count=0 # Initialize count of function evaluations

# starting parameter values
# let's say I start with exploring erepro in my 7 species model 
#startpars <- rep(0.001,times =length(mariaParams$species)) #initial erepro values as a test

#initial values from the steady state calculations - we do optim on the log scale
#startpars <- log(stedTas@species_params$erepro)

#how many params will I calibrate? 
#erepro for all species 
#gamma  for all species 
#interaction: avail of Trachinops, Pictilabrus and urchins

startpars_erepro <- log(mariaParams$erepro)
startpars_gamma <- mariaParams$gamma
startpars_inter <- c(availTr, availPi, availUr, availUrLob)
#startpars <- c(0.35, 0.6, 0.6)

startpars <- c(startpars_erepro, startpars_gamma, startpars_inter)

# Now describe the optim function that will do the search 

optim_result <-optimParallel(startpars,                   # starting parameter values
                     fn= calibratePar_Tasm,      # function to feed parameter values to the mizer object, run the model and return the error. It calls other functions from itself
                     mariaParams = mariaParams,       # pass the original parameter file (John passed his sim object after the burn-in period but I don't run burn-in for now)
                     inter = inter,
                     meansteps = meansteps.par,      # how many last years to use for the mean biomass calculations
                     #extinction_test=TRUE,      # I use it    
  lower = lower_bounds(startpars, inter.opt = T, erepro.opt = T, gamma.opt = T, inter.mult = inter.mult.par, erepro.mult = erepro.mult.par, gamma.mult = gamma.mult.par),
  upper = upper_bounds(startpars, inter.opt = T, erepro.opt = T, gamma.opt = T, inter.mult = inter.mult.par, erepro.mult = erepro.mult.par, gamma.mult = gamma.mult.par),
                     method="L-BFGS-B",
                     control=list(maxit=10, REPORT=1, trace=6), 
                     effort = effort, 
  parallel = list(loginfo = TRUE, forward = TRUE))

library("optimParallel")
library("parallel")
cl <- makeCluster(detectCores())
cl <- makeCluster(6)

setDefaultCluster(cl = cl)
clusterEvalQ(cl, library(mizer))

#in optim function have parallel = list(loginfo = TRUE, forward = TRUE)
#optim hessian=TRUE will give you parameter correlations and 

#For erepro calibration you want to print this
#exp(optim_result$par)/exp(startpars)

#For interaction calibration print this 
optim_result$par

#save(optim_result, file = "optim_resultFeb12.RData")

```




### Run   

```{r warning=FALSE, message=FALSE, echo=T}

### setup again with new erepro
params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, min_w_pp = min_w_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa)

## again update initial abundances based on observations 
for (i in 1:length(mariaParams$species)) {
  params@initial_n[i,] <- params@initial_n[i,] *abund_scalar[i]
} 

## add senescence and juvenile mortality to background mortality 
params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) + juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)

#params@species_params$erepro[which(params@species_params$species == "D_lewini")] <- 0.024
#params@species_params$erepro[which(params@species_params$species == "P_bachus")] <- 0.0099

## setup run time 
tmax = 100
dt = 0.2
tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt, diet_steps = 1)
plot(tasm1)
```

### Pred kernel experiments 

```{r}
tmax = 100
dt = 0.2
tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt, diet_steps = 0)
plot(tasm1)

params2 <- change_pred_kernel(params, params@pred_kernel)
tasm2 <- project(params2, t_max = tmax, effort= 0, dt = dt, diet_steps = 0)
plot(tasm2)

```

### Get biomass and RDD/rmax

```{r warning=FALSE, message=FALSE, echo=T}

## total biomass at last step
getBiomass(tasm1)[tmax,]
plotDietComp(tasm1)

#Check where they are at rmax level

model <- tasm1

a1 <- getRDI(params,model@n[tmax,,],model@n_pp[tmax,], model@n_bb[tmax,], model@n_aa[tmax,], model@intTempScalar[,,(tmax/dt)], model@metTempScalar[,,(tmax/dt)])

#get RDD 
a2 <- getRDD(params,model@n[tmax,,],model@n_pp[tmax,], model@n_bb[tmax,], model@n_aa[tmax,], sex_ratio = 0.5, model@intTempScalar[,,(tmax/dt)], model@metTempScalar[,,(tmax/dt)])

#get RDD to rmax ratio
a2/mariaParams$r_max

#1-a2/a1


```

### Run with fishing   

```{r warning=FALSE, message=FALSE, echo=T}

#now run with some fishing mortality (equal to all)

tasm1ef <- project(params, t_max = tmax, effort=0.2, dt = 0.2, diet_steps = 1)  
plot(tasm1ef)

getBiomass(tasm1ef)[tmax,]/getBiomass(tasm1)[tmax,]
plotDietComp(tasm1ef)

```

### Net intake through time (e)

```{r warning=FALSE, message=FALSE, echo=T}

model <- tasm1

#get the net intake values (starvation mortality is e/(0.1*w))

intake_matrix <- array(NA, dim = c(length(params@species_params$species), no_size_groups, tmax))

for (i in 1:tmax) {
  timetoget <- i

e_values <- getEReproAndGrowth(params,model@n[timetoget,,],model@n_pp[timetoget,], model@n_bb[timetoget,], model@n_aa[timetoget,], model@intTempScalar[,,(timetoget/dt)], model@metTempScalar[,,(timetoget/dt)])

intake_matrix[,,i] <- e_values

}

timetoplot = seq(from = 1, to = tmax, by = 20)

#create a colour gradient to plot
colfunc <- colorRampPalette(c("black", "lightgrey"))
mycol <- colfunc(length(timetoplot))

for (i in 1:length(mariaParams$species)) {
  
  first_slot <- max(which(params@w < mariaParams$w_min[i])) #only plot relevant size values
  last_slot <- min(which(params@w > mariaParams$w_inf[i]))
  
  plot(log(params@w[c(first_slot:last_slot)]),intake_matrix[i,c(first_slot:last_slot),1], type = 'l', xlab = 'Log size, g', ylab = 'net intake, g', main = mariaParams$species[i])
      for (j in 1:length(timetoplot)) {
        points(log(params@w[c(first_slot:last_slot)]),intake_matrix[i,c(first_slot:last_slot),j],type = 'l', col = mycol[j])
      }
  abline(v = log(mariaParams$w_mat[i]), lty = 2, col = 'orange')
  abline(h = 0, lty = 1, col = 'red')
  
}

##
starvMort <- (intake_matrix)/(0.1*params@w)
starvMort[intake_matrix>0] <- 0
starvMort <- -starvMort


```

### Background depletion 

```{r warning=FALSE, message=FALSE, echo=T}

tasm1 <- tasm1

smallcut <- max(which(tasm1@params@w_full < min_w_bb)) +1
largecut <- min(which(tasm1@params@w_full > w_bb_cutoff)) -1

largecutP <- min(which(tasm1@params@w_full > w_pp_cutoff)) -1

smallcutA <- max(which(tasm1@params@w_full < min_w_aa)) +1
largecutA <- min(which(tasm1@params@w_full > w_aa_cutoff)) -1

plot(log(tasm1@params@w_full[c(smallcut:largecut)]), (tasm1@n_bb[tmax,c(smallcut:largecut)]/tasm1@n_bb[1,c(smallcut:largecut)]),ylim = c(0,1), xlim = c( log(tasm1@params@w_full[1]), log(tasm1@params@w_full[largecut])), type = 'l', col = 'red', xlab = "log weight,g", ylab = "depletion compared to initial abundance", main = "Depletion of plankton, benthos(red) and algae(green)")
points(log(tasm1@params@w_full[c(1:largecutP)]), (tasm1@n_pp[tmax,c(1:largecutP)]/tasm1@n_pp[1,c(1:largecutP)]),type = 'l', col = 'black')
points(log(tasm1@params@w_full[c(smallcutA:largecutA)]), (tasm1@n_aa[tmax,c(smallcutA:largecutA)]/tasm1@n_aa[1,c(smallcutA:largecutA)]),type = 'l', col = 'green')


```

### Growth curves    
Plot and check individual growth curves. Note that the reference curves are based on vb_k and Linf, and vb_k is a highly uncertain parameter for many species. So black refrence curves are not good in many species. 

```{r warning=FALSE, message=FALSE, echo=T}

## growth curves
for (i in 1: length(params@species_params$species)) {
  
  plotGrowthCurves(tasm1, species = params@species_params$species[i])
  #plotGrowthCurves(tasm1temp, species = params@species_params$species[i])
  #plotFeedingLevel(tasm1, species = params@species_params$species[i])

}
```

#Plot all sizespectra at a chosen time

```{r warning=FALSE, message=FALSE, echo=T}
tplot =50

model <- tasm1

#plot size spectra
plot(log(model@params@w_full), log(model@n_pp[tplot,]), type = 'l', ylim = c(-30,30), xlim = c(-15,15),lwd = 2, xlab = 'size, g', ylab = 'abundance')
points(log(model@params@w_full), log(model@n_bb[tplot,]), type = 'l', lwd = 2, col = 'red')
points(log(model@params@w_full), log(model@n_aa[tplot,]), type = 'l', lwd = 1, col = 'green')

for (i in 1: length(params@species_params$species)) {
  points(log(model@params@w), log(model@n[tplot,i,]), type = 'l')
  
}

ppatmat = log(mariaParams$w_mat/mariaParams$beta) # prefered prey size at predators maturation size
abline(v = c(ppatmat), lty = 2, col = 'grey')

abline(v = log(mariaParams$w_mat), lty = 2, col = 'yellow')

```

### Run again with optim

```{r warning=FALSE, message=FALSE, echo=T}

#put optimised parameters into the param matrix
 mariaParams$erepro <- exp(optim_result$par[c(1:no_sp)])

 #Then put the gamma values
 mariaParams$gamma <- optim_result$par[c((no_sp+1):(no_sp*2))]

 ###now update the interaction matrix
 interPars <- optim_result$par[c((no_sp*2+1):(no_sp*2+4))]
  
 inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- interPars[1]
inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- interPars[2]
inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- interPars[3]
inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- interPars[4]



### setup again with new erepro
params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, min_w_pp = min_w_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa)

## again update initial abundances based on observations 
#for (i in 1:length(mariaParams$species)) {
# get the name of the species for indexing 
#  sppname <- as.character(mariaParams$species[i])
  # multiply initial abundances by the relative abundance of this species in the observations. Also multiply it by the total_scalar applied to all species to get the abundance closer to the equilibrium conditons 
  #params@initial_n[i,] <- params@initial_n[i,] * observ_abund$scaledAbund[which(observ_abund$species == sppname)] * total_scalar
#  params@initial_n[i,] <- params@initial_n[i,] *sc[i]
#} 

## add senescence and juvenile mortality to background mortality 
params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) + juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)

#params@species_params$erepro[which(params@species_params$species == "D_lewini")] <- 0.024
#params@species_params$erepro[which(params@species_params$species == "P_bachus")] <- 0.0099

## setup run time 
tmax = 250
dt = 0.2
tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt, diet_steps = 1)
plot(tasm1)

```











### Mortality - FIX

The graph is not perfect, but a quick look at the assumed juvenile and senescence mortality functions and how they compare with the predation mortality. Minimum size is shown with dashed blue line, maturation size is shown with orange lines. Basically we see that juvenile mortality is very high at minimum sizes and drops quickly at around sizes 0.1g, by which time predation becomes a more important force. Note, no juvenile mortality is imposed on sharks, for which min size is assumed to be 1g. Senescence mortality kicks in just before the 90% of maximum size. The curves look steep, but the maximum values are around 1 at maximum size. 

```{r warning=FALSE, message=FALSE, echo=T}

#at which time to plot 
year = 50

m2mort <- getM2(params,model@n[year,,],model@n_pp[year,], model@n_bb[year,], model@n_aa[year,], model@intTempScalar[,,(year/dt)])

getPredMort <- function(object, n, n_pp, n_bb, n_aa, pred_rate, intakeScalar, time_range, drop = TRUE

# get predation mortality 
m2mort <- getM2(model, model@intTempScalar[,,(year/dt)], )[year,,]
#get non-predation mortality 
nonm2mort <- params@mu_b

#plot non predation mort
plot(log(params@dw), nonm2mort[1,], type = 'l', ylim = c(0, 5), col = 'grey', xlab = "log size, g", ylab = "instantaneous mortality", main = "Non-predation and predation (red) mortality")
for (i in 2:length(mariaParams$species)) {
  points(log(params@dw), nonm2mort[i,], type = 'l')  
}
#add predation 
for (i in 1:length(mariaParams$species)) {
  points(log(params@dw), m2mort[i,], type = 'l', col = 'red')  
}
#who w_min
abline(v = log(mariaParams$w_min), lty = 2, col  = 'blue')
abline(v = log(mariaParams$w_mat), lty = 2, col  = 'orange')

#totmort <- getM2(tasm1)[tmax,,] + params@mu_b

#or just explore non predation mortality
#plot(x = log(tasm1@params@w), tasm1@params@mu_b[1,], ylim = c(0,50), type = 'l')
#for (i in 1: length(params@species_params$species)) {
#  points(log(tasm1@params@w), tasm1@params@mu_b[i,], type = 'l')
#}
#abline(v = log(mariaParams$w_min), lty = 2, col  = 'red')
#abline(v = log(mariaParams$w_inf), lty = 2, col  = 'blue')


```

### Size spectra  

Initial and final abundance at size: still too many individuals at largest sizes

```{r warning=FALSE, message=FALSE, echo=T}
#plot initial and final abundance 
par(mfrow = c(1,2))

mycol = c('black','red', 'green', 'orange','blue','violet','pink','grey','yellow','black','red', 'green', 'orange','blue','violet','pink','grey','yellow')

#initial
plot(log(params@w), log(params@initial_n[1,]), type = 'l', ylim = c(-40, max(log(params@initial_n[]))), main = "initial n", xlab = "log w", ylab = "numbers")

for (i in 2:length(params@species_params$species)) {
  points(log(params@w), log(params@initial_n[i,]), type = 'l', col = mycol [i] )
}
abline (h = c(0,-10,-20,-30), lty = 2, col = 'grey')
abline (v = c(-5,0,5), lty = 2, col = 'grey')

#final
plot(log(params@w), log(tasm1ef@n[tmax,1,]), type = 'l', ylim = c(-40, max(log(params@initial_n[]))), main = "final n", xlab = "log w", ylab = "numbers")

for (i in 2:length(params@species_params$species)) {
  points(log(params@w), log(tasm1ef@n[tmax,i,]), type = 'l', col = mycol [i] )
}
abline (h = c(0,-10,-20,-30), lty = 2, col = 'grey')
abline (v = c(-5,0,5), lty = 2, col = 'grey')
par(mfrow = c(1,1))

```


### Plot initial densities 
```{r}

plot(log(params@w_full), log(params@initial_n_pp), type = 'l', xlim = c(-10,10), ylim = c(-30,30), col = 'grey')
points(log(params@w_full), log(params@initial_n_aa), type = 'l', col = 'green')
points(log(params@w_full), log(params@initial_n_bb), type = 'l', col = 'red')

for (i in 1: length(params@species_params$species)) {
  points(log(params@w), log(params@initial_n[i,]), type = 'l')
  
} 

# default initial abundances are quite far from the observed ones 

#get the minimum observed weight size group 
minobs <- min(which(params@w > 0.1))

#get mean model abundances in the observed weight groups (so they are comparable to surveys)
modelAb <- rep(NA, length(params@species_params$species))
## derive initial abundance scalar 
for (i in 1:length(mariaParams$species)) {
modelAb[i] <- (sum(params@initial_n[i,c(minobs:200)]))
}

#get a scalar between observed abundances and model abundances 
sc <- (params@species_params$meanAb/500)/modelAb

#plot them again, this time species abundances adjusted
plot(log(params@w_full), log(params@initial_n_pp), type = 'l', xlim = c(-10,10), ylim = c(-30,10), col = 'grey')
points(log(params@w_full), log(params@initial_n_aa), type = 'l', col = 'green')
points(log(params@w_full), log(params@initial_n_bb), type = 'l', col = 'red')

for (i in 1: length(params@species_params$species)) {
  points(log(params@w), log(params@initial_n[i,]*sc[i]), type = 'l')
  
} 



plot(params@w_full, params@initial_n_pp, type = 'l', xlim = c(0.1,20), ylim = c(0,200), xlab = 'weight,g', ylab = 'numbers')
points((params@w_full), (params@initial_n_aa), type = 'l', col = 'green')
points((params@w_full), (params@initial_n_bb), type = 'l', col = 'red')

biom_pp <- params@w_full * params@initial_n_pp
biom_aa <- params@w_full * params@initial_n_aa
biom_bb <- params@w_full * params@initial_n_bb

plot(params@w_full, biom_pp, type = 'l', xlim = c(0.1,20), ylim = c(0,50), xlab = 'weight,g', ylab = 'biomass,g')
points((params@w_full), biom_aa, type = 'l', col = 'green')
points((params@w_full), biom_bb, type = 'l', col = 'red')

sum(biom_bb)
sum(biom_aa)
sum(biom_pp)

```



### 
Lobsters eat small fish and urchins. They used to be the dominant predator of small fish (hypothesis)

Southern and eastern rock lobster 
Southern calamari and snapper thermal preference 

Use relative abundance and use species specific size spectra from the first 5 years 


1. Fishing mortality using data inside and outside MPA
2. Benthic resource slope and regeneration rate and how they change with temperature and what does it mean to the community 
3. How does temperature alter the community structure inside MPA using long term data

how are these systems functioning?
how does fishing and climate affect that?






